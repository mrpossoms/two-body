<html>
<head>
<link href="css/style.css" rel="stylesheet">
<link href="css/bootstrap.min.css" rel="stylesheet">
<script type="text/javascript" src="js/g.js"></script>
<script type="text/javascript" src="js/g.web.js"></script>
<script type="text/javascript" src="js/elements.js"></script>
<script type="text/javascript">

const k = {
    mouse: {
        sensitivity: 0.01,
    },
};


var view_q = [0,0,0,1];
var cam = new g.web.gfx.camera();
var mouse_down = false;
var t = 0;
var el = new orbital_elements();

el.v0 = [0, 0, 1];
el.e = 0.0;
el.i = 0;

function on_load()
{
const base = window.location.pathname.replace('index.html', '');
const asset_list = [
	base + 'shaders/basic_textured.vert',
	base + 'shaders/basic_textured.frag',
    base + 'shaders/basic_color.vert',
    base + 'shaders/basic_color.frag',
    base + 'shaders/body.vert',
    base + 'shaders/body.frag',
	base + 'meshes/exported-cube.json',
    base + 'meshes/plane.json',
	base + 'imgs/stars.jpg',
];

function controls_for(properties)
{
    for (var i = properties.length; i--;)
    {
        const prop = properties[i];
        const e = document.getElementById(prop);

        if (!e) { console.error('no element ' + prop); continue; }

        function handler(prop)
        {
            var chain = prop.split('.');

            var targ = window;
            var val = chain[0];
            for (var j = 1; j < chain.length; j++)
            {
                targ = targ[val];
                val = chain[j];
            }

            e.oninput = function(event)
            {
                console.log(event.target.valueAsNumber);
                targ[val] = event.target.valueAsNumber;
            };
        }

        e.handler = new handler(prop);
    }
}

controls_for([ 'el.i', 'el.e', 'el.ω' ]);

g.web.canvas(document.getElementsByTagName('canvas')[0], {fixed_size: true});

g.initialize(function ()
{
    g.is_running = false;

    g.web.assets.load(asset_list,
    function() {
        g.web.gfx.shader.create('basic_textured',
            g.web.assets[base + 'shaders/basic_textured.vert'],
            g.web.assets[base + 'shaders/basic_textured.frag']
        );

        g.web.gfx.shader.create('body',
            g.web.assets[base + 'shaders/body.vert'],
            g.web.assets[base + 'shaders/body.frag']
        );

        g.web.gfx.shader.create('basic_color',
            g.web.assets[base + 'shaders/basic_color.vert'],
            g.web.assets[base + 'shaders/basic_color.frag']
        );

        g.is_running = true;

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.lineWidth(1);

        g.web.assets['mesh/point'] = g.web.gfx.mesh.create({ positions: [0, 0, 0]});

        g.web.assets['mesh/basis'] = g.web.gfx.mesh.create({
            positions: [
                0, 0, 0, 1, 0, 0,
                0, 0, 0, 0, 1, 0,
                0, 0, 0, 0, 0, 1,
            ],
            colors: [
                1, 0, 0, 1, 1, 0, 0, 1,
                0, 1, 0, 1, 0, 1, 0, 1,
                0, 0, 1, 1, 0, 0, 1, 1,
            ]
        });

        g.web.assets['mesh/line'] = g.web.gfx.mesh.create({
            positions: [ 0, 0, 0, 1, 0, 0, ],
            colors: [ 1, 1, 1, 0.5, 1, 1, 1, 0.5, ]
        });
    },
    function(complete) {
        document.getElementById('server_msg').innerText = Math.ceil(100 * complete) + '%';
    });

	return true;
});


g.web.pointer.on_move(function (event)
{
    if (g.is_running == false) { return; }

    if (!mouse_down) { return; }

    const dqx = [].quat_rotation([0, 1, 0], event.movementX * k.mouse.sensitivity);
    const dqy = [].quat_rotation([1, 0, 0], event.movementY * k.mouse.sensitivity);
    const dq = dqx.quat_mul(dqy);

    view_q = view_q.quat_mul(dq);
});

g.web.pointer.on_press(function (e) { mouse_down = true; });

g.web.pointer.on_release(function (e) { mouse_down = false; });

g.update(function (dt)
{

});


function update_camera(camera, focus, q, dist, dt)
{
    camera.position = [0, 0, el.a() * 2];
    camera.look_at(camera.position, [0, 0, 0], [0, 1, 0]);
}

function draw_body(position, mass, light_dir)
{
    const model = [].scale(mass).mat_mul([].translate(position.mul(-1)));

    gl.enable(gl.DEPTH_TEST);
    g.web.assets['mesh/point'].using_shader('body')
                         .with_attribute({name:'a_position', buffer: 'positions', components: 3})
                         .set_uniform('u_proj').mat4(cam.projection())
                         .set_uniform('u_view').mat4(view_q.quat_to_matrix().mat_mul(cam.view()))
                         .set_uniform('u_model').mat4(model)
                         .set_uniform('u_rot').mat4(view_q.quat_to_matrix())
                         .set_uniform('u_mass').float(mass)
                         .set_uniform('u_light_dir').vec3(light_dir)
                         .draw_points();
}

function draw_skybox()
{
    g.web.assets[base + 'mesh/exported-cube'].using_shader('basic_textured')
                             .with_attribute({name:'a_position', buffer: 'positions', components: 3})
                             .with_attribute({name:'a_tex_coord', buffer: 'texture_coords', components: 2})
                             .set_uniform('u_proj').mat4(cam.projection())
                             .set_uniform('u_view').mat4(view_q.quat_to_matrix())
                             .set_uniform('u_model').mat4([].scale(500))
                             .set_uniform('u_texture').texture(g.web.assets[base + 'tex/stars'])
                             .draw_tris();
    gl.enable(gl.DEPTH_TEST);
}

function draw_basis()
{
    g.web.assets['mesh/basis'].using_shader('basic_color')
                             .with_attribute({name:'a_position', buffer: 'positions', components: 3})
                             .with_attribute({name:'a_color', buffer: 'colors', components: 4})
                             .set_uniform('u_proj').mat4(cam.projection())
                             .set_uniform('u_view').mat4(view_q.quat_to_matrix().mat_mul(cam.view()))
                             .set_uniform('u_model').mat4([].scale(2))
                             .draw_lines();
}

function draw_orbit(path_func, steps, dt)
{
    steps = steps || 100;
    dt = dt || 0.1;

    for (var s = 0; s < steps; ++s)
    {
        const t_0 = s * dt;
        const t_1 = (s + 1) * dt;
        const line = g.web.assets['mesh/line'];

        line.buffer('positions').set_data([path_func(t_0), path_func(t_1)]);

        line.using_shader('basic_color')
            .with_attribute({name:'a_position', buffer: 'positions', components: 3})
            .with_attribute({name:'a_color', buffer: 'colors', components: 4})
            .set_uniform('u_proj').mat4(cam.projection())
            .set_uniform('u_view').mat4(view_q.quat_to_matrix().mat_mul(cam.view()))
            .set_uniform('u_model').mat4([].scale(1))
            .draw_lines();
    }
}

g.web.draw(function (dt)
{
    if (g.is_running == false) { return; }
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    update_camera(cam, [0, 0, -1], view_q, 10, dt);
    cam.perspective(Math.PI / 3, 0.1, 1000);

    draw_skybox();

    const light_dir = [ -1, 0, 0 ].norm();

    function orbit_wrapper(t)
    {
        return el.location(t);
    }

    draw_body([0, 0, 0], 2.5, light_dir);
    draw_body(orbit_wrapper(t), 0.5, light_dir);
    draw_basis();
    draw_orbit(orbit_wrapper);

    t += dt;
});

g.start();
}

</script>
</head>

<body class="container-fluid bg-dark" onload="on_load()">
<h1 class="text-light">Orbital Elements Calculator</h1>
<section class="row">

<canvas class="col" width=640 height=480></canvas>

<section class="input-group col">
    <!-- Argument of periapsis -->
    <label class="text-light" for="arg-of-periapsis">ω</label>
    <input id="el.ω" type="range" class="custom-range" min="0" max="360" value=0>

    <!-- eccentricity -->
    <label class="text-light" for="eccentricity">e</label>
    <input id="el.e" type="range" class="custom-range" step="0.01" min="0" max="1" value=0>

    <!-- inclination -->
    <label class="text-light" for="inclination">i</label>
    <input id="el.i" type="range" class="custom-range" min="0" max="180" value="0">

    <!-- longitude of ascending node -->
<!--     <label class="text-light" for="inclination">Ω</label>
    <input type="range" class="custom-range" min="0" max="360" id="lng-of-ascending-node"> -->

</section>

</section>



</body>
</html>
