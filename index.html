<html>
<head>
<link href="css/style.css" rel="stylesheet">
<script type="text/javascript" src="js/g.js"></script>
<script type="text/javascript" src="js/g.web.js"></script>
<script type="text/javascript">

const k = {
    mouse: {
        sensitivity: 0.01,
    },
};

function orbital_elements()
{
    this.eccentricity = 0;
    this.inclination = 0;
    this.argument_of_pariapsis = 0;
    this.u = 1;

    this.r = function(t)
    {
        // TODO
    };

    this.v = function(t)
    {
        // TODO
    };

    this.h = function(t)
    {
        return this.r(t).cross(this.v(t));
    };

    this.line_of_nodes = function(t)
    {

    };
}

var view_q = [0,0,0,1];
var cam = new g.web.gfx.camera();
var mouse_down = false;
var t = 0;

function on_load()
{
const base = window.location.pathname.replace('index.html', '');
const asset_list = [
	base + 'shaders/basic_textured.vert',
	base + 'shaders/basic_textured.frag',
    base + 'shaders/basic_color.vert',
    base + 'shaders/basic_color.frag',
    base + 'shaders/body.vert',
    base + 'shaders/body.frag',
	base + 'meshes/exported-cube.json',
    base + 'meshes/plane.json',
	base + 'imgs/stars.jpg',
];


g.web.canvas(document.getElementsByTagName('canvas')[0], {fixed_size: true});

g.initialize(function ()
{
    g.is_running = false;

    g.web.assets.load(asset_list,
    function() {
        g.web.gfx.shader.create('basic_textured',
            g.web.assets[base + 'shaders/basic_textured.vert'],
            g.web.assets[base + 'shaders/basic_textured.frag']
        );

        g.web.gfx.shader.create('body',
            g.web.assets[base + 'shaders/body.vert'],
            g.web.assets[base + 'shaders/body.frag']
        );

        g.web.gfx.shader.create('basic_color',
            g.web.assets[base + 'shaders/basic_color.vert'],
            g.web.assets[base + 'shaders/basic_color.frag']
        );

        g.is_running = true;

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.lineWidth(1);

        g.web.assets['mesh/point'] = g.web.gfx.mesh.create({ positions: [0, 0, 0]});

        g.web.assets['mesh/basis'] = g.web.gfx.mesh.create({
            positions: [
                0, 0, 0, 1, 0, 0,
                0, 0, 0, 0, 1, 0,
                0, 0, 0, 0, 0, 1,
            ],
            colors: [
                1, 0, 0, 1, 1, 0, 0, 1,
                0, 1, 0, 1, 0, 1, 0, 1,
                0, 0, 1, 1, 0, 0, 1, 1,
            ]
        });

        g.web.assets['mesh/line'] = g.web.gfx.mesh.create({
            positions: [ 0, 0, 0, 1, 0, 0, ],
            colors: [ 1, 1, 1, 0.5, 1, 1, 1, 0.5, ]
        });
    },
    function(complete) {
        document.getElementById('server_msg').innerText = Math.ceil(100 * complete) + '%';
    });

	return true;
});


g.web.pointer.on_move(function (event)
{
    if (g.is_running == false) { return; }

    if (!mouse_down) { return; }

    const dqx = [].quat_rotation([0, 1, 0], event.movementX * k.mouse.sensitivity);
    const dqy = [].quat_rotation([1, 0, 0], event.movementY * k.mouse.sensitivity);
    const dq = dqx.quat_mul(dqy);

    view_q = view_q.quat_mul(dq);
});

g.web.pointer.on_press(function (e) { mouse_down = true; });

g.web.pointer.on_release(function (e) { mouse_down = false; });

g.update(function (dt)
{

});


function update_camera(camera, focus, q, dist, dt)
{
    camera.position = [0, 0, 5];
    camera.look_at(camera.position, [0, 0, 0], [0, 1, 0]);
}

function draw_body(position, mass, light_dir)
{
    const model = [].scale(mass).mat_mul([].translate(position));

    gl.enable(gl.DEPTH_TEST);
    g.web.assets['mesh/point'].using_shader('body')
                         .with_attribute({name:'a_position', buffer: 'positions', components: 3})
                         .set_uniform('u_proj').mat4(cam.projection())
                         .set_uniform('u_view').mat4(view_q.quat_to_matrix().mat_mul(cam.view()))
                         .set_uniform('u_model').mat4(model)
                         .set_uniform('u_rot').mat4(view_q.quat_to_matrix())
                         .set_uniform('u_mass').float(mass)
                         .set_uniform('u_light_dir').vec3(light_dir)
                         .draw_points();
}

function draw_skybox()
{
    g.web.assets[base + 'mesh/exported-cube'].using_shader('basic_textured')
                             .with_attribute({name:'a_position', buffer: 'positions', components: 3})
                             .with_attribute({name:'a_tex_coord', buffer: 'texture_coords', components: 2})
                             .set_uniform('u_proj').mat4(cam.projection())
                             .set_uniform('u_view').mat4(view_q.quat_to_matrix())
                             .set_uniform('u_model').mat4([].scale(500))
                             .set_uniform('u_texture').texture(g.web.assets[base + 'tex/stars'])
                             .draw_tris();
    gl.enable(gl.DEPTH_TEST);
}

function draw_basis()
{
    g.web.assets['mesh/basis'].using_shader('basic_color')
                             .with_attribute({name:'a_position', buffer: 'positions', components: 3})
                             .with_attribute({name:'a_color', buffer: 'colors', components: 4})
                             .set_uniform('u_proj').mat4(cam.projection())
                             .set_uniform('u_view').mat4(view_q.quat_to_matrix().mat_mul(cam.view()))
                             .set_uniform('u_model').mat4([].scale(2))
                             .draw_lines();
}

function draw_orbit(path_func, steps, dt)
{
    steps = steps || 100;
    dt = dt || 0.1;

    for (var s = 0; s < steps; ++s)
    {
        const t_0 = s * dt;
        const t_1 = (s + 1) * dt;
        const line = g.web.assets['mesh/line'];

        line.buffer('positions').set_data([path_func(t_0), path_func(t_1)]);

        line.using_shader('basic_color')
            .with_attribute({name:'a_position', buffer: 'positions', components: 3})
            .with_attribute({name:'a_color', buffer: 'colors', components: 4})
            .set_uniform('u_proj').mat4(cam.projection())
            .set_uniform('u_view').mat4(view_q.quat_to_matrix().mat_mul(cam.view()))
            .set_uniform('u_model').mat4([].scale(1))
            .draw_lines();
    }
}

g.web.draw(function (dt)
{
    if (g.is_running == false) { return; }
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    update_camera(cam, [0, 0, -1], view_q, 10, dt);
    cam.perspective(Math.PI / 3, 0.1, 1000);

    draw_skybox();

    const light_dir = [ -1, 0, 0 ].norm();

    function circular_orbit(t)
    {
        return [Math.cos(t), 0, Math.sin(t)].mul(2);
    }

    draw_body([0, 0, 0], 10, light_dir);
    draw_body(circular_orbit(t), 1, light_dir);
    draw_basis();
    draw_orbit(circular_orbit);

    t += dt;
});

g.start();
}

</script>
</head>

<body style="margin:0" onload="on_load()">
<center>
<p id="server_msg"></p>
<canvas width=640 height=640></canvas>
</center>

</body>
</html>
